================================================================================
MODULE 3: API ROUTES DEEP DIVE
================================================================================
Estimated Time: 45 minutes
Prerequisites: Module 3 of Beginner (routing overview), Module 1 of this level (generics)
Learning Objectives:
  - Understand how API routes differ from page routes in Fresh
  - Master the define.handlers() pattern with full typing
  - Handle GET, POST, PUT, DELETE with typed request/response
  - Parse JSON and FormData from request bodies safely
  - Return proper HTTP status codes and JSON
  - Handle errors gracefully with try/catch
================================================================================

In the Beginner level, you learned there are four route types.
API routes were mentioned briefly. Now we build them fully.

--------------------------------------------------------------------------------
LESSON 1: API ROUTES vs PAGE ROUTES
--------------------------------------------------------------------------------
In Fresh 2.x, there are two kinds of route files:

  PAGE ROUTE:
    - Default export is a Preact component
    - Returns HTML (the full page)
    - Example: routes/index.tsx

  API ROUTE:
    - No default export (or the export isn't used for rendering)
    - Exports a `handler` object
    - Returns a raw Response object (JSON, text, binary)
    - Example: routes/api/[name].tsx

The key difference: API routes NEVER produce HTML. They speak JSON (usually).
The browser JavaScript in your Islands calls them with `fetch()`.

HOW TO TELL THEM APART BY LOOKING AT THE FILE:

  // PAGE ROUTE — has a default export returning JSX:
  export default define.page(function Home() {
    return <div>Hello World</div>;
  });

  // API ROUTE — has an exported handler, NO JSX default export:
  export const handler = define.handlers({ ... });

A file can have BOTH (handler + page) — we cover that in Module 6.

--------------------------------------------------------------------------------
LESSON 2: THE EXISTING [name].tsx EXPLAINED LINE BY LINE
--------------------------------------------------------------------------------
File: routes/api/[name].tsx

  import { define } from "../../utils.ts";       // Line 1

`define` is created in utils.ts with `createDefine<State>()`. It gives you
type-safe handler and page factories. The `../../` goes up from api/ → routes/ → project root.

  export const handler = define.handlers({        // Line 3

`define.handlers()` takes an object where each KEY is an HTTP method name
(GET, POST, PUT, DELETE, PATCH) and each VALUE is the handler function.
The `handler` name is special — Fresh looks for this exact export name.

    GET(ctx) {                                     // Line 4

`GET` handles HTTP GET requests. `ctx` is the context object, typed by Fresh.
The method name MUST be uppercase: GET not get.

      const name = ctx.params.name;               // Line 5

`ctx.params` is a Record<string, string> of URL parameters.
Because the file is named `[name].tsx`, the `name` param is available.
URL /api/john → ctx.params.name === "john"

      return new Response(                        // Line 6-8
        `Hello, ${name.charAt(0).toUpperCase() + name.slice(1)}!`,
      );

Returns a plain text Response. No `ctx.render()` — that is for page routes.
`new Response(body, init?)` is the standard Web API Response constructor.

--------------------------------------------------------------------------------
LESSON 3: HANDLING ALL HTTP METHODS
--------------------------------------------------------------------------------
Here is the full handler pattern for a REST resource:

  // routes/api/notes.tsx
  import { define } from "../../utils.ts";

  export const handler = define.handlers({
    // GET /api/notes — return all notes
    GET(ctx) {
      return Response.json(getAllNotes());
      // Response.json() sets Content-Type: application/json automatically
    },

    // POST /api/notes — create a note
    async POST(ctx) {
      const body = await ctx.req.json();     // Parse JSON body
      const note = createNote(body.text);
      return Response.json(note, { status: 201 });
      // 201 Created — the standard status for successful creation
    },

    // DELETE /api/notes — delete a note by ID in the query string
    async DELETE(ctx) {
      const url    = new URL(ctx.req.url);
      const id     = url.searchParams.get("id");
      if (!id) return new Response("Missing id", { status: 400 });
      const deleted = deleteNoteById(id);
      if (!deleted) return new Response("Not found", { status: 404 });
      return new Response(null, { status: 204 });
      // 204 No Content — standard for successful delete with no body
    },
  });

HTTP STATUS CODES CHEAT SHEET:

  CODE   NAME              USE WHEN
  ----   ---------------   ----------------------------------------
  200    OK                Successful GET, PUT (with body)
  201    Created           Successful POST (resource was created)
  204    No Content        Successful DELETE (nothing to return)
  400    Bad Request       Client sent missing/invalid data
  401    Unauthorized      Not authenticated (no/invalid credentials)
  403    Forbidden         Authenticated but not allowed
  404    Not Found         Resource does not exist
  409    Conflict          Resource already exists (duplicate)
  500    Internal Error    Server crashed — something unexpected

  SHORTHAND HELPERS (avoid typing new Response every time):
    Response.json(data)              → 200 + JSON body
    Response.json(data, { status })  → custom status + JSON body
    new Response(null, { status: 204 }) → no body response

--------------------------------------------------------------------------------
LESSON 4: PARSING REQUEST BODIES
--------------------------------------------------------------------------------
When the client sends data (POST, PUT, PATCH), it arrives in the request BODY.

JSON BODY (most common for API calls from JavaScript):
  async POST(ctx) {
    const body = await ctx.req.json();           // Parse JSON, returns unknown
    // ALWAYS validate before using:
    if (typeof body.text !== "string") {
      return new Response("Invalid body", { status: 400 });
    }
    const note = createNote(body.text as string);
    return Response.json(note, { status: 201 });
  }

FORM DATA (for HTML forms with enctype="application/x-www-form-urlencoded"):
  async POST(ctx) {
    const form = await ctx.req.formData();
    const text = form.get("text");
    if (!text || typeof text !== "string") {
      return new Response("Missing text", { status: 400 });
    }
    const note = createNote(text);
    return Response.json(note, { status: 201 });
  }

URL QUERY PARAMETERS (for filtering/searching in GET):
  GET(ctx) {
    const url    = new URL(ctx.req.url);
    const search = url.searchParams.get("q") ?? "";
    const filtered = getAllNotes().filter(n => n.text.includes(search));
    return Response.json(filtered);
  }

READING HEADERS (e.g. for auth):
  GET(ctx) {
    const auth  = ctx.req.headers.get("Authorization");
    const token = auth?.replace("Bearer ", "") ?? "";
    if (!isValidToken(token)) {
      return new Response("Unauthorized", { status: 401 });
    }
    return Response.json(getAllNotes());
  }

--------------------------------------------------------------------------------
LESSON 5: ADDING RESPONSE HEADERS
--------------------------------------------------------------------------------
You may need to set headers on the response — for CORS support, caching, etc.

  GET(ctx) {
    return Response.json(getAllNotes(), {
      headers: {
        "Cache-Control":                "no-store",
        "Access-Control-Allow-Origin":  "*",   // Allow any origin (dev only!)
        "X-Total-Count":                String(getAllNotes().length),
      },
    });
  }

For a more complex API that adds headers to every response, use middleware
(covered in Module 4).

--------------------------------------------------------------------------------
LESSON 6: BUILDING THE FULL NOTES API
--------------------------------------------------------------------------------
This is the complete API you will build in Module 7 (Hands-On).
Study the structure here; you will implement it step-by-step there.

  // routes/api/notes.tsx

  import { define } from "../../utils.ts";

  // ---------- In-memory data store ----------
  // In a real app this would be a database. For this project, it lives in memory.
  // It resets every time the server restarts.
  interface Note {
    id: string;
    text: string;
    createdAt: string;
  }

  const store: Record<string, Note> = {};

  function getAllNotes(): Note[] {
    return Object.values(store).sort((a, b) =>
      b.createdAt.localeCompare(a.createdAt)
    );
  }

  function createNote(text: string): Note {
    const note: Note = {
      id:        crypto.randomUUID(),
      text,
      createdAt: new Date().toISOString(),
    };
    store[note.id] = note;
    return note;
  }

  function deleteNote(id: string): boolean {
    if (!store[id]) return false;
    delete store[id];
    return true;
  }

  // ---------- HTTP Handlers ----------
  export const handler = define.handlers({
    // GET /api/notes?q=optional_filter
    GET(ctx) {
      const url    = new URL(ctx.req.url);
      const search = url.searchParams.get("q") ?? "";
      const notes  = search
        ? getAllNotes().filter(n => n.text.toLowerCase().includes(search.toLowerCase()))
        : getAllNotes();
      return Response.json(notes);
    },

    // POST /api/notes  body: { text: string }
    async POST(ctx) {
      let body: unknown;
      try {
        body = await ctx.req.json();
      } catch {
        return new Response("Invalid JSON", { status: 400 });
      }

      if (
        typeof body !== "object" ||
        body === null ||
        typeof (body as { text: unknown }).text !== "string" ||
        (body as { text: string }).text.trim() === ""
      ) {
        return new Response("text is required and must be a non-empty string", { status: 400 });
      }

      const note = createNote((body as { text: string }).text.trim());
      return Response.json(note, { status: 201 });
    },

    // DELETE /api/notes?id=...
    DELETE(ctx) {
      const url = new URL(ctx.req.url);
      const id  = url.searchParams.get("id");
      if (!id) return new Response("id query param is required", { status: 400 });
      const deleted = deleteNote(id);
      if (!deleted) return new Response("Note not found", { status: 404 });
      return new Response(null, { status: 204 });
    },
  });

ERROR HANDLING PATTERN:
  Always wrap body parsing in try/catch. `ctx.req.json()` throws if the body
  is not valid JSON. Never let an unhandled exception crash your handler —
  Fresh will return a 500 error to the client, which is confusing to debug.

--------------------------------------------------------------------------------
LESSON 7: CALLING YOUR API FROM AN ISLAND
--------------------------------------------------------------------------------
Once the API route exists, call it from your Island's client-side code:

  // Inside an Island:
  async function loadNotes() {
    isLoading.value = true;
    try {
      const res = await fetch("/api/notes");
      if (!res.ok) throw new Error(`${res.status}`);
      notes.value = await res.json() as Note[];
    } catch (e) {
      error.value = (e as Error).message;
    } finally {
      isLoading.value = false;
    }
  }

  async function addNote(text: string) {
    const res = await fetch("/api/notes", {
      method:  "POST",
      headers: { "Content-Type": "application/json" },
      body:    JSON.stringify({ text }),
    });
    if (!res.ok) return;
    const note = await res.json() as Note;
    notes.value = [note, ...notes.value]; // Optimistic update
  }

  async function removeNote(id: string) {
    const res = await fetch(`/api/notes?id=${id}`, { method: "DELETE" });
    if (!res.ok) return;
    notes.value = notes.value.filter(n => n.id !== id);
  }

`finally { isLoading.value = false; }` — runs WHETHER the fetch succeeded or
failed, so the loading spinner always disappears.

--------------------------------------------------------------------------------
QUICK REFERENCE
--------------------------------------------------------------------------------

  HANDLER KEY       matches HTTP         ctx provides
  ---------------   ------------------   -------------------------------------------
  GET(ctx)          GET requests         ctx.params, ctx.req.url, ctx.req.headers
  POST(ctx)         POST requests        ctx.req.json(), ctx.req.formData()
  PUT(ctx)          PUT requests         ctx.req.json()
  PATCH(ctx)        PATCH requests       ctx.req.json()
  DELETE(ctx)       DELETE requests      ctx.params, ctx.req.url

  RESPONSE HELPERS:
    Response.json(data)               200 + JSON body
    Response.json(data, {status:201}) 201 + JSON body
    new Response("text", {status:400}) 400 + text body
    new Response(null, {status:204})  204 + empty body

  PARSING HELPERS:
    ctx.req.json()        → Promise<unknown> (throws on invalid JSON)
    ctx.req.formData()    → Promise<FormData>
    new URL(ctx.req.url)  → URL object
    url.searchParams.get("key") → string | null

--------------------------------------------------------------------------------
MINI QUIZ
--------------------------------------------------------------------------------
1. You want to create a new resource. Which HTTP method and status code are correct?
   A) GET, 200
   B) POST, 201
   C) PUT, 204
   D) DELETE, 200

2. `ctx.req.json()` throws. When does this happen?
   A) When the server is busy
   B) When the JSON body is malformed or the Content-Type is wrong
   C) When the request has no params
   D) When the response is 404

3. What does `Response.json(data)` do automatically that `new Response(JSON.stringify(data))` does NOT?
   A) Sets status 201
   B) Validates the data
   C) Sets the Content-Type: application/json header
   D) Encrypts the response

4. You want a client to search notes by keyword. What is the idiomatic approach?
   A) PUT /api/notes with the keyword in the body
   B) GET /api/notes?q=keyword (URL query param)
   C) POST /api/search with the keyword in the body
   D) GET /api/notes/keyword (dynamic route segment)

Answers: 1-B, 2-B, 3-C, 4-B

================================================================================
