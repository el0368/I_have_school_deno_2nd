================================================================================
MODULE 7: HANDS-ON — THE NOTES APP
================================================================================
Estimated Time: 60 minutes
Goal: Build a complete Notes App end-to-end using ALL intermediate concepts:
  ✓ Advanced TypeScript (generics, utility types, discriminated unions)
  ✓ Advanced Signals (computed, effect, batch, shared store)
  ✓ API Routes (full CRUD — GET, POST, DELETE)
  ✓ Middleware (scoped auth guard, request logger)
  ✓ Testing (unit tests + integration tests)
  ✓ Advanced Fresh Patterns (layout, handler+page, Head, redirect)
================================================================================

Before you start: `deno task dev` must be running.
Open: http://localhost:5174

Files you will create in this module:

  routes/
    notes.tsx                ← Page + handler (route module pattern)
    _layout.tsx              ← Shared navigation layout
    api/
      notes.tsx              ← Full CRUD REST API
      _middleware.ts         ← Scoped API auth guard

  islands/
    NotesIsland.tsx          ← Interactive Island with computed + effect

  logic.test.ts              ← EXPANDED with real tests (modify existing)

--------------------------------------------------------------------------------
STEP 1: DEFINE THE DATA MODEL AND IN-MEMORY STORE
--------------------------------------------------------------------------------
We will put the shared data model and store in a SEPARATE FILE so both the
API route and the tests can import it.

Create: store/notes.ts
  // store/notes.ts
  // This file contains the data model and all data operations.
  // It has NO Fresh or Preact imports — pure TypeScript logic.

  // ---- Types ----
  export interface Note {
    id: string;
    text: string;
    createdAt: string;
  }

  // Omit the server-generated fields for the "create" input:
  export type CreateNoteInput = Omit<Note, "id" | "createdAt">;

  // ---- In-Memory Store ----
  // In a real app, this would be a PostgreSQL / SQLite / KV database.
  const store: Record<string, Note> = {};

  // ---- Data Operations ----
  export function getAllNotes(): Note[] {
    return Object.values(store).sort((a, b) =>
      b.createdAt.localeCompare(a.createdAt) // newest first
    );
  }

  export function getNoteById(id: string): Note | undefined {
    return store[id];
  }

  export function createNote(input: CreateNoteInput): Note {
    const note: Note = {
      id:        crypto.randomUUID(),
      text:      input.text.trim(),
      createdAt: new Date().toISOString(),
    };
    store[note.id] = note;
    return note;
  }

  export function deleteNoteById(id: string): boolean {
    if (!store[id]) return false;
    delete store[id];
    return true;
  }

  // ---- Test Helper (not exported to production usage) ----
  export function _clearStore() {
    Object.keys(store).forEach(k => delete store[k]);
  }

WHY A SEPARATE FILE:
  The API route imports from it, the test file imports from it.
  Neither depends on the other. This is the "separation of concerns" principle.
  The data logic is TESTABLE without starting a server.

--------------------------------------------------------------------------------
STEP 2: BUILD THE NOTES API (routes/api/notes.tsx)
--------------------------------------------------------------------------------
Create: routes/api/notes.tsx
  import { define } from "../../utils.ts";
  import {
    getAllNotes, createNote, deleteNoteById
  } from "../../store/notes.ts";

  export const handler = define.handlers({
    // GET /api/notes?q=optional_search
    GET(ctx) {
      const url    = new URL(ctx.req.url);
      const search = url.searchParams.get("q")?.toLowerCase() ?? "";
      const notes  = search
        ? getAllNotes().filter(n => n.text.toLowerCase().includes(search))
        : getAllNotes();
      return Response.json(notes);
    },

    // POST /api/notes  body: { text: string }
    async POST(ctx) {
      let body: unknown;
      try {
        body = await ctx.req.json();
      } catch {
        return new Response("Invalid JSON body", { status: 400 });
      }

      const text = (body as { text?: unknown }).text;
      if (typeof text !== "string" || text.trim() === "") {
        return new Response("'text' must be a non-empty string", { status: 400 });
      }

      const note = createNote({ text });
      return Response.json(note, { status: 201 });
    },

    // DELETE /api/notes?id=...
    DELETE(ctx) {
      const url = new URL(ctx.req.url);
      const id  = url.searchParams.get("id");
      if (!id) return new Response("'id' query param required", { status: 400 });

      const deleted = deleteNoteById(id);
      return deleted
        ? new Response(null, { status: 204 })
        : new Response("Note not found", { status: 404 });
    },
  });

TEST IT IN TERMINAL:
  # Create a note:
  curl -X POST http://localhost:5174/api/notes \
    -H "Content-Type: application/json" \
    -d '{"text":"My first note"}'

  # Get all notes:
  curl http://localhost:5174/api/notes

  # Delete (replace ID with the one returned above):
  curl -X DELETE "http://localhost:5174/api/notes?id=YOUR_ID_HERE"

--------------------------------------------------------------------------------
STEP 3: ADD THE SCOPED API MIDDLEWARE (routes/api/_middleware.ts)
--------------------------------------------------------------------------------
Create: routes/api/_middleware.ts
  import { define } from "../../utils.ts";

  // In production: set API_KEY env variable to something secret.
  // For local dev: use the fallback "dev-key".
  const API_KEY = Deno.env.get("API_KEY") ?? "dev-key";

  export const handler = define.middleware(async (ctx) => {
    const key = ctx.req.headers.get("X-API-Key");
    if (key !== API_KEY) {
      return Response.json(
        { error: "Unauthorized: missing or invalid X-API-Key header" },
        { status: 401 }
      );
    }
    return ctx.next();
  });

UPDATE YOUR API TESTS:
  After adding middleware, your curl commands need the header:
  curl -H "X-API-Key: dev-key" http://localhost:5174/api/notes

SKIPPING AUTH IN TESTS:
  For unit tests against the store functions directly, auth is irrelevant
  (we test the data layer, not the HTTP layer). Only add the header if you
  write HTTP-level integration tests using `fetch("http://localhost:5174/...")`.

--------------------------------------------------------------------------------
STEP 4: BUILD THE LAYOUT (routes/_layout.tsx)
--------------------------------------------------------------------------------
Create: routes/_layout.tsx
  import { define } from "../utils.ts";

  export default define.page(function Layout({ Component }) {
    return (
      <div style={{ fontFamily: "system-ui, sans-serif", maxWidth: "800px", margin: "0 auto" }}>
        <nav style={{
          background: "#1e293b",
          padding: "14px 24px",
          borderRadius: "0 0 8px 8px",
          display: "flex",
          gap: "24px",
          marginBottom: "32px"
        }}>
          <a href="/" style={{ color: "#94a3b8", textDecoration: "none", fontWeight: "bold" }}>
            Fresh App
          </a>
          <a href="/notes" style={{ color: "white", textDecoration: "none" }}>Notes</a>
          <a href="/hello" style={{ color: "white", textDecoration: "none" }}>Hello MDX</a>
        </nav>
        <Component />
      </div>
    );
  });

After saving, visit http://localhost:5174 — the nav bar appears on every page!

--------------------------------------------------------------------------------
STEP 5: BUILD THE NOTES ISLAND (islands/NotesIsland.tsx)
--------------------------------------------------------------------------------
Create: islands/NotesIsland.tsx
  import { signal, computed, effect, batch } from "@preact/signals";
  import type { Note } from "../store/notes.ts";

  interface NotesIslandProps {
    initialNotes: Note[];  // Server pre-loads existing notes
  }

  export default function NotesIsland({ initialNotes }: NotesIslandProps) {
    // State signals
    const notes     = signal<Note[]>(initialNotes);
    const draft     = signal("");
    const isLoading = signal(false);
    const errorMsg  = signal<string | null>(null);

    // Derived (computed) signals — auto-update when `notes` changes:
    const noteCount = computed(() => notes.value.length);
    const hasNotes  = computed(() => notes.value.length > 0);
    const isEmpty   = computed(() => draft.value.trim() === "");

    // Side-effect: log note count whenever it changes (demo of effect()):
    effect(() => {
      console.log(`[NotesIsland] Note count changed: ${noteCount.value}`);
    });

    async function handleAdd() {
      if (isEmpty.value) return;
      isLoading.value = true;
      try {
        const res = await fetch("/api/notes", {
          method:  "POST",
          headers: {
            "Content-Type": "application/json",
            "X-API-Key":    "dev-key",
          },
          body: JSON.stringify({ text: draft.value }),
        });
        if (!res.ok) {
          const msg = await res.text();
          errorMsg.value = msg;
          return;
        }
        const newNote = await res.json() as Note;
        batch(() => {
          notes.value    = [newNote, ...notes.value]; // Prepend newest
          draft.value    = "";                        // Clear input
          errorMsg.value = null;                      // Clear error
        });
      } finally {
        isLoading.value = false;
      }
    }

    async function handleDelete(id: string) {
      const res = await fetch(`/api/notes?id=${id}`, {
        method:  "DELETE",
        headers: { "X-API-Key": "dev-key" },
      });
      if (res.ok) {
        notes.value = notes.value.filter(n => n.id !== id);
      }
    }

    return (
      <div>
        <h2>My Notes ({noteCount})</h2>

        {errorMsg.value && (
          <p style={{ color: "red", background: "#fee2e2", padding: "8px", borderRadius: "4px" }}>
            {errorMsg}
          </p>
        )}

        <div style={{ display: "flex", gap: "8px", marginBottom: "16px" }}>
          <input
            type="text"
            value={draft}
            placeholder="Write a note..."
            onInput={(e) => { draft.value = e.currentTarget.value; }}
            onKeyDown={(e) => { if (e.key === "Enter") handleAdd(); }}
            style={{ flex: 1, padding: "8px 12px", borderRadius: "4px", border: "1px solid #cbd5e1" }}
          />
          <button
            onClick={handleAdd}
            disabled={isEmpty.value || isLoading.value}
            style={{
              padding: "8px 16px",
              background: isEmpty.value ? "#94a3b8" : "#3b82f6",
              color: "white",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer"
            }}
          >
            {isLoading.value ? "Adding..." : "Add"}
          </button>
        </div>

        {!hasNotes.value && (
          <p style={{ color: "#94a3b8" }}>No notes yet. Add one above!</p>
        )}

        <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
          {notes.value.map(note => (
            <li key={note.id} style={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              padding: "10px 14px",
              marginBottom: "8px",
              background: "#f8fafc",
              borderRadius: "6px",
              border: "1px solid #e2e8f0"
            }}>
              <span>{note.text}</span>
              <button
                onClick={() => handleDelete(note.id)}
                style={{ background: "#dc2626", color: "white", border: "none", borderRadius: "4px", padding: "4px 10px", cursor: "pointer" }}
              >
                Delete
              </button>
            </li>
          ))}
        </ul>
      </div>
    );
  }

WHAT EACH CONCEPT IS DOING HERE:
  signal()    → notes, draft, isLoading, errorMsg — core reactive state
  computed()  → noteCount, hasNotes, isEmpty — auto-derived, never stale
  effect()    → logs note count change to console (demonstrates the API)
  batch()     → updates notes + draft + errorMsg in one render pass
  initialNotes prop → server pre-renders the list (no loading flash!)

--------------------------------------------------------------------------------
STEP 6: BUILD THE NOTES PAGE (routes/notes.tsx)
--------------------------------------------------------------------------------
Create: routes/notes.tsx
  import { Head } from "fresh/runtime";
  import { define } from "../utils.ts";
  import { getAllNotes } from "../store/notes.ts";
  import NotesIsland from "../islands/NotesIsland.tsx";

  export default define.page(function NotesPage() {
    // Pre-load existing notes ON THE SERVER before sending HTML to browser.
    // The Island receives them as initialNotes — no loading flash.
    const initialNotes = getAllNotes();

    return (
      <div>
        <Head>
          <title>My Notes — Fresh App</title>
          <meta name="description" content="Manage your personal notes" />
        </Head>
        <NotesIsland initialNotes={initialNotes} />
      </div>
    );
  });

Visit: http://localhost:5174/notes
You should see the Notes Island with the Add button and empty state message.
Add some notes — they appear instantly. Delete them — they disappear instantly.
Refresh the page — the notes are GONE (in-memory store resets on server restart).

--------------------------------------------------------------------------------
STEP 7: WRITE THE TESTS (logic.test.ts expanded)
--------------------------------------------------------------------------------
Replace the contents of logic.test.ts with:

  import { assertEquals, assertExists, assert, assertNotEquals } from "jsr:@std/assert";
  import {
    createNote, getAllNotes, getNoteById, deleteNoteById, _clearStore
  } from "./store/notes.ts";

  // ---- createNote ----
  Deno.test("createNote: returns a note with id, text, and createdAt", () => {
    _clearStore();
    const note = createNote({ text: "Hello test" });

    assertExists(note.id);
    assertEquals(note.text, "Hello test");
    assertExists(note.createdAt);
    assert(note.id.length > 0);
    assert(note.createdAt.includes("T")); // ISO format check
  });

  Deno.test("createNote: trims whitespace from text", () => {
    _clearStore();
    const note = createNote({ text: "  spaces  " });
    assertEquals(note.text, "spaces");
  });

  Deno.test("createNote: generates unique IDs", () => {
    _clearStore();
    const a = createNote({ text: "Note A" });
    const b = createNote({ text: "Note B" });
    assertNotEquals(a.id, b.id);
  });

  // ---- getAllNotes ----
  Deno.test("getAllNotes: returns all notes in the store", () => {
    _clearStore();
    createNote({ text: "First" });
    createNote({ text: "Second" });
    assertEquals(getAllNotes().length, 2);
  });

  Deno.test("getAllNotes: returns newest first", async (t) => {
    _clearStore();
    createNote({ text: "Older" });
    // Small delay so createdAt is different:
    await new Promise(r => setTimeout(r, 10));
    createNote({ text: "Newer" });
    const notes = getAllNotes();
    await t.step("first item is newest", () => {
      assertEquals(notes[0].text, "Newer");
    });
    await t.step("second item is older", () => {
      assertEquals(notes[1].text, "Older");
    });
  });

  // ---- getNoteById ----
  Deno.test("getNoteById: returns the correct note", () => {
    _clearStore();
    const note = createNote({ text: "Find me" });
    const found = getNoteById(note.id);
    assertExists(found);
    assertEquals(found!.text, "Find me");
  });

  Deno.test("getNoteById: returns undefined for unknown id", () => {
    _clearStore();
    const result = getNoteById("fake-id-12345");
    assertEquals(result, undefined);
  });

  // ---- deleteNoteById ----
  Deno.test("deleteNoteById: returns true and removes the note", () => {
    _clearStore();
    const note = createNote({ text: "Delete me" });
    assertEquals(deleteNoteById(note.id), true);
    assertEquals(getNoteById(note.id), undefined);
    assertEquals(getAllNotes().length, 0);
  });

  Deno.test("deleteNoteById: returns false for unknown id", () => {
    _clearStore();
    assertEquals(deleteNoteById("does-not-exist"), false);
  });

  // ---- Basic math (keep the original test) ----
  Deno.test("basic math validation", () => {
    assertEquals(2 + 2, 4);
  });

RUN THE TESTS:
  deno test --reporter=verbose

EXPECTED OUTPUT:
  running 9 tests from ./logic.test.ts
  createNote: returns a note with id, text, and createdAt ... ok (1ms)
  createNote: trims whitespace from text ... ok (0ms)
  createNote: generates unique IDs ... ok (0ms)
  getAllNotes: returns all notes in the store ... ok (0ms)
  getAllNotes: returns newest first ... ok (12ms)
  getNoteById: returns the correct note ... ok (0ms)
  getNoteById: returns undefined for unknown id ... ok (0ms)
  deleteNoteById: returns true and removes the note ... ok (0ms)
  deleteNoteById: returns false for unknown id ... ok (0ms)
  basic math validation ... ok (0ms)
  ok | 10 passed | 0 failed (16ms)

--------------------------------------------------------------------------------
COMMON INTERMEDIATE ERRORS
--------------------------------------------------------------------------------

ERROR 1: "Export 'createNote' not found in './store/notes.ts'"
  FIX: Make sure the function is exported: `export function createNote(...)`

ERROR 2: Island shows stale data after adding a note (UI doesn't update)
  FIX: Make sure you're assigning a NEW array: `notes.value = [newNote, ...notes.value]`
       NOT: `notes.value.push(newNote)` ← Signals don't detect mutations to the same array

ERROR 3: computed() value doesn't update
  FIX: The computed fn must READ `.value` from the signal inside it:
       WRONG: computed(() => notes.length)          ← reads .length of the signal object itself
       RIGHT: computed(() => notes.value.length)    ← reads the value array then its length

ERROR 4: "Unauthorized" on every API call even with the right key
  FIX: Check capitalisation. The middleware checks `X-API-Key` (case-sensitive headers vary).
       In the Island: `"X-API-Key": "dev-key"` — must match exactly.

ERROR 5: Test order matters — later test fails because of data from earlier test
  FIX: Call `_clearStore()` at the start of every test that needs a clean state.

ERROR 6: The layout nav bar appears on API routes too (browser shows JSON under the nav)
  FIX: Move the _layout.tsx to a subfolder, or add a check in the layout:
       const isApi = ctx.req.url.includes("/api/");
       if (isApi) return <Component />;
       (Or just leave it as-is — the JSON response bypasses the layout for API calls)

--------------------------------------------------------------------------------
WHAT TO EXPLORE NEXT (AFTER THIS MODULE)
--------------------------------------------------------------------------------
You have now built a complete intermediate-level Fresh 2.x application.
Here are paths to go deeper:

  1. PERSISTENCE: Replace the in-memory store with Deno KV:
     https://docs.deno.com/deploy/kv/manual/
     `const kv = await Deno.openKv();`

  2. DEPLOYMENT: Deploy your Fresh app to Deno Deploy (free tier):
     https://deno.com/deploy
     `deno deploy` handles the whole stack — no server config.

  3. ADVANCED TESTING: Test actual HTTP endpoints with a running server:
     https://fresh.deno.dev/docs/concepts/testing

  4. AUTHENTICATION: Add real auth with session cookies using Fresh's
     session plugin or a library like `deno_kv_oauth`.

  5. DATABASE: Connect to PostgreSQL using the `postgres` npm package:
     `import { Client } from "npm:pg";`

  6. FULL SIGNALS DOCS: https://preactjs.com/guide/v10/signals/

  7. ADVANCED TYPESCRIPT: Mapped types, conditional types, infer keyword.
     "TypeScript Deep Dive" (free online book) covers all of it.

================================================================================
CONGRATULATIONS — INTERMEDIATE LEVEL COMPLETE!
================================================================================
You have built:
  ✓ A full REST API (GET, POST, DELETE with proper status codes)
  ✓ A scoped auth middleware (routes/api/_middleware.ts)
  ✓ A shared navigation layout (_layout.tsx)
  ✓ A reactive Island with computed(), effect(), and batch()
  ✓ Tests for every data operation with proper isolation

When you are ready, move on to the Advanced level.

================================================================================
